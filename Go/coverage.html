
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>classes: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go_classes/classes/DoubleList.go (97.6%)</option>
				
				<option value="file1">go_classes/classes/FBTree.go (95.9%)</option>
				
				<option value="file2">go_classes/classes/ForwardList.go (97.0%)</option>
				
				<option value="file3">go_classes/classes/MyArray.go (91.7%)</option>
				
				<option value="file4">go_classes/classes/MyQueue.go (95.2%)</option>
				
				<option value="file5">go_classes/classes/MyStack.go (96.7%)</option>
				
				<option value="file6">go_classes/classes/OpenTable.go (92.0%)</option>
				
				<option value="file7">go_classes/classes/TableHash.go (88.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package classes

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "os"
)

// Node представляет узел двусвязного списка
type Node[T comparable] struct {
        Key  T
        Next *Node[T]
        Prev *Node[T]
}

// DoubleList представляет двусвязный список
type DoubleList[T comparable] struct {
        Head *Node[T]
        Tail *Node[T]
}

// NewDoubleList создает новый пустой список
func NewDoubleList[T comparable]() *DoubleList[T] <span class="cov8" title="1">{
        return &amp;DoubleList[T]{}
}</span>

// LCreate инициализирует список первым элементом
func (l *DoubleList[T]) LCreate(keyBegin T) error <span class="cov8" title="1">{
        if l.Head != nil </span><span class="cov8" title="1">{
                return errors.New("logic_error: List already created. Use push methods")
        }</span>
        <span class="cov8" title="1">newNode := &amp;Node[T]{Key: keyBegin}
        l.Head = newNode
        l.Tail = newNode
        return nil</span>
}

// LPushHead добавляет элемент в начало
func (l *DoubleList[T]) LPushHead(key T) <span class="cov8" title="1">{
        newNode := &amp;Node[T]{Key: key, Next: l.Head, Prev: nil}
        if l.Head != nil </span><span class="cov8" title="1">{
                l.Head.Prev = newNode
        }</span> else<span class="cov8" title="1"> {
                l.Tail = newNode
        }</span>
        <span class="cov8" title="1">l.Head = newNode</span>
}

// LPushBack добавляет элемент в конец
func (l *DoubleList[T]) LPushBack(key T) <span class="cov8" title="1">{
        newNode := &amp;Node[T]{Key: key, Next: nil, Prev: l.Tail}
        if l.Tail != nil </span><span class="cov8" title="1">{
                l.Tail.Next = newNode
        }</span> else<span class="cov8" title="1"> {
                l.Head = newNode
        }</span>
        <span class="cov8" title="1">l.Tail = newNode</span>
}

// LDelHead удаляет первый элемент
func (l *DoubleList[T]) LDelHead() error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return errors.New("underflow_error: Attempt to delete head in an empty list")
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next
        if l.Head != nil </span><span class="cov8" title="1">{
                l.Head.Prev = nil
        }</span> else<span class="cov8" title="1"> {
                l.Tail = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LDelBack удаляет последний элемент
func (l *DoubleList[T]) LDelBack() error <span class="cov8" title="1">{
        if l.Tail == nil </span><span class="cov8" title="1">{
                return errors.New("underflow_error: Attempt to delete tail in an empty list")
        }</span>
        <span class="cov8" title="1">l.Tail = l.Tail.Prev
        if l.Tail != nil </span><span class="cov8" title="1">{
                l.Tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                l.Head = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LGetByValue ищет узел по значению
func (l *DoubleList[T]) LGetByValue(key T) *Node[T] <span class="cov8" title="1">{
        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                if current.Key == key </span><span class="cov8" title="1">{
                        return current
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LPushBefore вставляет элемент перед указанным значением
func (l *DoubleList[T]) LPushBefore(targetKey T, newKey T) error <span class="cov8" title="1">{
        targetNode := l.LGetByValue(targetKey)
        if targetNode == nil </span><span class="cov8" title="1">{
                return errors.New("invalid_argument: Target element for insertion (BEFORE) not found")
        }</span>

        <span class="cov8" title="1">if targetNode == l.Head </span><span class="cov8" title="1">{
                l.LPushHead(newKey)
                return nil
        }</span>

        <span class="cov8" title="1">newNode := &amp;Node[T]{Key: newKey, Next: targetNode, Prev: targetNode.Prev}
        targetNode.Prev.Next = newNode
        targetNode.Prev = newNode
        return nil</span>
}

// LPushAfter вставляет элемент после указанного значения
func (l *DoubleList[T]) LPushAfter(targetKey T, newKey T) error <span class="cov8" title="1">{
        targetNode := l.LGetByValue(targetKey)
        if targetNode == nil </span><span class="cov8" title="1">{
                return errors.New("invalid_argument: Target element for insertion (AFTER) not found")
        }</span>

        <span class="cov8" title="1">if targetNode == l.Tail </span><span class="cov8" title="1">{
                l.LPushBack(newKey)
                return nil
        }</span>

        <span class="cov8" title="1">newNode := &amp;Node[T]{Key: newKey, Next: targetNode.Next, Prev: targetNode}
        targetNode.Next.Prev = newNode
        targetNode.Next = newNode
        return nil</span>
}

// LDelAfter удаляет элемент после указанного значения
func (l *DoubleList[T]) LDelAfter(targetKey T) error <span class="cov8" title="1">{
        targetNode := l.LGetByValue(targetKey)
        if targetNode == nil </span><span class="cov8" title="1">{
                return errors.New("invalid_argument: Target element for deletion (AFTER) not found")
        }</span>
        <span class="cov8" title="1">if targetNode.Next == nil </span><span class="cov8" title="1">{
                return errors.New("logic_error: No elements after the specified node")
        }</span>

        <span class="cov8" title="1">nodeToDelete := targetNode.Next
        if nodeToDelete == l.Tail </span><span class="cov8" title="1">{
                return l.LDelBack()
        }</span>

        <span class="cov8" title="1">targetNode.Next = nodeToDelete.Next
        if nodeToDelete.Next != nil </span><span class="cov8" title="1">{
                nodeToDelete.Next.Prev = targetNode
        }</span>
        // nodeToDelete будет удален GC
        <span class="cov8" title="1">return nil</span>
}

// LDelBefore удаляет элемент перед указанным значением
func (l *DoubleList[T]) LDelBefore(targetKey T) error <span class="cov8" title="1">{
        targetNode := l.LGetByValue(targetKey)
        if targetNode == nil </span><span class="cov8" title="1">{
                return errors.New("invalid_argument: Target element for deletion (BEFORE) not found")
        }</span>
        <span class="cov8" title="1">if targetNode.Prev == nil </span><span class="cov8" title="1">{
                return errors.New("logic_error: No elements before the specified node (it is the head)")
        }</span>

        <span class="cov8" title="1">nodeToDelete := targetNode.Prev
        if nodeToDelete == l.Head </span><span class="cov8" title="1">{
                return l.LDelHead()
        }</span>

        <span class="cov8" title="1">targetNode.Prev = nodeToDelete.Prev
        if nodeToDelete.Prev != nil </span><span class="cov8" title="1">{
                nodeToDelete.Prev.Next = targetNode
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LDelByValue удаляет первое вхождение элемента по значению
func (l *DoubleList[T]) LDelByValue(key T) error <span class="cov8" title="1">{
        targetNode := l.LGetByValue(key)
        if targetNode == nil </span><span class="cov8" title="1">{
                return errors.New("invalid_argument: Element with such value not found")
        }</span>

        <span class="cov8" title="1">if targetNode == l.Head </span><span class="cov8" title="1">{
                return l.LDelHead()
        }</span>
        <span class="cov8" title="1">if targetNode == l.Tail </span><span class="cov8" title="1">{
                return l.LDelBack()
        }</span>

        <span class="cov8" title="1">targetNode.Prev.Next = targetNode.Next
        targetNode.Next.Prev = targetNode.Prev
        return nil</span>
}

// Clone создает глубокую копию списка
func (l *DoubleList[T]) Clone() *DoubleList[T] <span class="cov8" title="1">{
        newList := NewDoubleList[T]()
        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                newList.LPushBack(current.Key)
                current = current.Next
        }</span>
        <span class="cov8" title="1">return newList</span>
}

// Print выводит список.
func (l *DoubleList[T]) Print(w io.Writer, choice int) error <span class="cov8" title="1">{
        switch choice </span>{
        case 1:<span class="cov8" title="1"> // Forward
                if l.Head == nil </span><span class="cov8" title="1">{
                        fmt.Fprintln(w, "Список пуст.")
                        return nil
                }</span>
                <span class="cov8" title="1">current := l.Head
                fmt.Fprint(w, "Голова -&gt; ")
                for current != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%v &lt;-&gt; ", current.Key)
                        current = current.Next
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(w, "nullptr")</span>
        case 2:<span class="cov8" title="1"> // Backward
                if l.Tail == nil </span><span class="cov8" title="1">{
                        fmt.Fprintln(w, "Список пуст.")
                        return nil
                }</span>
                <span class="cov8" title="1">current := l.Tail
                fmt.Fprint(w, "Хвост -&gt; ")
                for current != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%v &lt;-&gt; ", current.Key)
                        current = current.Prev
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(w, "nullptr")</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid_argument: Invalid print mode selection")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LSave сохраняет список в текстовый файл
func (l *DoubleList[T]) LSave(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(file, "%v ", current.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LLoad загружает список из текстового файла
func (l *DoubleList[T]) LLoad(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Очистка текущего списка
        l.Head = nil
        l.Tail = nil

        var value T
        for </span><span class="cov8" title="1">{
                _, err := fmt.Fscan(file, &amp;value)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">l.LPushBack(value)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LSaveBin сохраняет список в бинарный файл
func (l *DoubleList[T]) LSaveBin(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                // binary.Write работает корректно для фиксированных типов (int32, float64 и т.д.)
                if err := binary.Write(file, binary.LittleEndian, current.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LLoadBin загружает список из бинарного файла
func (l *DoubleList[T]) LLoadBin(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        l.Head = nil
        l.Tail = nil

        var value T
        for </span><span class="cov8" title="1">{
                err := binary.Read(file, binary.LittleEndian, &amp;value)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">l.LPushBack(value)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package classes

import (
        "cmp"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "os"
)

// Константы для визуализации
const (
        branchRight = "|--- "
        branchLeft  = "|___ "
)

// TreeNode представляет узел дерева
type TreeNode[T cmp.Ordered] struct {
        Key   T
        Left  *TreeNode[T]
        Right *TreeNode[T]
}

// FullBinaryTree представляет обертку над деревом
type FullBinaryTree[T cmp.Ordered] struct {
        root *TreeNode[T]
}

// NewFullBinaryTree создает новое пустое дерево
func NewFullBinaryTree[T cmp.Ordered]() *FullBinaryTree[T] <span class="cov8" title="1">{
        return &amp;FullBinaryTree[T]{}
}</span>

// GetRoot возвращает корень
func (t *FullBinaryTree[T]) GetRoot() *TreeNode[T] <span class="cov8" title="1">{
        return t.root
}</span>

// Insert вставка элемента по принципу BST
func (t *FullBinaryTree[T]) Insert(value T) <span class="cov8" title="1">{
        newNode := &amp;TreeNode[T]{Key: value}

        if t.root == nil </span><span class="cov8" title="1">{
                t.root = newNode
                return
        }</span>

        <span class="cov8" title="1">current := t.root
        var parent *TreeNode[T]

        for current != nil </span><span class="cov8" title="1">{
                parent = current
                if value &lt; current.Key </span><span class="cov8" title="1">{
                        current = current.Left
                }</span> else<span class="cov8" title="1"> {
                        current = current.Right
                }</span>
        }

        <span class="cov8" title="1">if value &lt; parent.Key </span><span class="cov8" title="1">{
                parent.Left = newNode
        }</span> else<span class="cov8" title="1"> {
                parent.Right = newNode
        }</span>
}

// IsFull проверяет, является ли дерево полным
func (t *FullBinaryTree[T]) IsFull() bool <span class="cov8" title="1">{
        if t.root == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return isFullRecursive(t.root)</span>
}

func isFullRecursive[T cmp.Ordered](node *TreeNode[T]) bool <span class="cov8" title="1">{
        // Если ((left == nil) XOR (right == nil)) == true, то это неполное дерево
        hasLeft := node.Left != nil
        hasRight := node.Right != nil

        if hasLeft != hasRight </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if hasLeft &amp;&amp; hasRight </span><span class="cov8" title="1">{
                return isFullRecursive(node.Left) &amp;&amp; isFullRecursive(node.Right)
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Clone создает глубокую копию дерева
func (t *FullBinaryTree[T]) Clone() *FullBinaryTree[T] <span class="cov8" title="1">{
        newTree := NewFullBinaryTree[T]()
        newTree.root = copyTreeRecursive(t.root)
        return newTree
}</span>

func copyTreeRecursive[T cmp.Ordered](node *TreeNode[T]) *TreeNode[T] <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">newNode := &amp;TreeNode[T]{Key: node.Key}
        newNode.Left = copyTreeRecursive(node.Left)
        newNode.Right = copyTreeRecursive(node.Right)
        return newNode</span>
}

// Print - единый метод вывода.
// w - куда писать (os.Stdout для консоли или bytes.Buffer для тестов)
func (t *FullBinaryTree[T]) Print(choice int, w io.Writer) error <span class="cov8" title="1">{
        switch choice </span>{
        case 1:<span class="cov8" title="1">
                t.printBreadthFirst(w)</span>
        case 2:<span class="cov8" title="1">
                t.preOrderRecursive(t.root, w)
                fmt.Fprintln(w)</span>
        case 3:<span class="cov8" title="1">
                t.inOrderRecursive(t.root, w)
                fmt.Fprintln(w)</span>
        case 4:<span class="cov8" title="1">
                t.postOrderRecursive(t.root, w)
                fmt.Fprintln(w)</span>
        case 5:<span class="cov8" title="1">
                t.printTreeVisual(t.root, w)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("invalid print operation code: %d", choice)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Методы обхода

func (t *FullBinaryTree[T]) printBreadthFirst(w io.Writer) <span class="cov8" title="1">{
        if t.root == nil </span><span class="cov8" title="1">{
                return
        }</span>
        // Простая реализация очереди на слайсе
        <span class="cov8" title="1">queue := []*TreeNode[T]{t.root}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:] // pop

                fmt.Fprintf(w, "%v ", current.Key)

                if current.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Left)
                }</span>
                <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Right)
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(w)</span>
}

func (t *FullBinaryTree[T]) preOrderRecursive(node *TreeNode[T], w io.Writer) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%v ", node.Key)
                t.preOrderRecursive(node.Left, w)
                t.preOrderRecursive(node.Right, w)
        }</span>
}

func (t *FullBinaryTree[T]) inOrderRecursive(node *TreeNode[T], w io.Writer) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                t.inOrderRecursive(node.Left, w)
                fmt.Fprintf(w, "%v ", node.Key)
                t.inOrderRecursive(node.Right, w)
        }</span>
}

func (t *FullBinaryTree[T]) postOrderRecursive(node *TreeNode[T], w io.Writer) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                t.postOrderRecursive(node.Left, w)
                t.postOrderRecursive(node.Right, w)
                fmt.Fprintf(w, "%v ", node.Key)
        }</span>
}

// Визуализация

func (t *FullBinaryTree[T]) printTreeVisual(node *TreeNode[T], w io.Writer) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                fmt.Fprintln(w, "Дерево пустое.")
                return
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(w, node.Key)
        printTreeVisualRecursive(node.Right, "", false, w)
        printTreeVisualRecursive(node.Left, "", true, w)</span>
}

func printTreeVisualRecursive[T cmp.Ordered](node *TreeNode[T], prefix string, isLeft bool, w io.Writer) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                fmt.Fprint(w, prefix)
                if isLeft </span><span class="cov8" title="1">{
                        fmt.Fprint(w, branchLeft)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprint(w, branchRight)
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(w, node.Key)

                newPrefix := prefix
                if isLeft </span><span class="cov8" title="1">{
                        newPrefix += "|   "
                }</span> else<span class="cov8" title="1"> {
                        newPrefix += "    "
                }</span>

                <span class="cov8" title="1">printTreeVisualRecursive(node.Right, newPrefix, false, w)
                printTreeVisualRecursive(node.Left, newPrefix, true, w)</span>
        }
}

// Файловый ввод-вывод (Текстовый)

func (t *FullBinaryTree[T]) SaveText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("couldn't open the file for writing: %s (%w)", filename, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if t.root == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">queue := []*TreeNode[T]{t.root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                if _, err := fmt.Fprintf(file, "%v ", current.Key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error writing data to file: %w", err)
                }</span>

                <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Left)
                }</span>
                <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Right)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *FullBinaryTree[T]) LoadText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("couldn't open the file for reading: %s (%w)", filename, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Очистка текущего дерева
        t.root = nil

        var value T
        for </span><span class="cov8" title="1">{
                // Fscan автоматически пропускает пробелы
                _, err := fmt.Fscan(file, &amp;value)
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("critical I/O error when reading file: %w", err)
                }</span>
                <span class="cov8" title="1">t.Insert(value)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Файловый ввод-вывод (Бинарный)

func (t *FullBinaryTree[T]) SaveBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("binary file could not be opened: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        return serializeRecursive(t.root, file)</span>
}

func serializeRecursive[T cmp.Ordered](node *TreeNode[T], w io.Writer) error <span class="cov8" title="1">{
        exists := node != nil
        // Пишем маркер (bool как int8/byte для простоты переносимости)
        var marker int8
        if exists </span><span class="cov8" title="1">{
                marker = 1
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.LittleEndian, marker); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                if err := binary.Write(w, binary.LittleEndian, node.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := serializeRecursive(node.Left, w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := serializeRecursive(node.Right, w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *FullBinaryTree[T]) LoadBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("the binary file could not be opened: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        t.root = nil
        var root *TreeNode[T]

        err = deserializeRecursive(&amp;root, file)
        if err != nil </span><span class="cov8" title="1">{
                // В случае ошибки дерево остается пустым или частично заполненным
                t.root = nil
                return err
        }</span>
        <span class="cov8" title="1">t.root = root
        return nil</span>
}

func deserializeRecursive[T cmp.Ordered](node **TreeNode[T], r io.Reader) error <span class="cov8" title="1">{
        var marker int8
        if err := binary.Read(r, binary.LittleEndian, &amp;marker); err != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        return nil // Нормальный конец рекурсии, если структура соблюдена
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if marker != 0 &amp;&amp; marker != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file format: expected marker 0 or 1, got %d", marker)
        }</span>

        <span class="cov8" title="1">if marker == 1 </span><span class="cov8" title="1">{
                var val T
                if err := binary.Read(r, binary.LittleEndian, &amp;val); err != nil </span><span class="cov8" title="1">{
                        return errors.New("unexpected end of file or node data reading error")
                }</span>
                <span class="cov8" title="1">newNode := &amp;TreeNode[T]{Key: val}
                *node = newNode
                if err := deserializeRecursive(&amp;newNode.Left, r); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := deserializeRecursive(&amp;newNode.Right, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                *node = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package classes

import (
        "bytes"
        "encoding/gob"
        "fmt"
        "io"
        "os"
)

// FLNode представляет узел списка
type FLNode[T any] struct {
        Key  T
        Next *FLNode[T]
}

// ForwardList реализует односвязный список
type ForwardList[T comparable] struct {
        Head *FLNode[T]
}

// NewForwardList создает новый пустой список
func NewForwardList[T comparable]() *ForwardList[T] <span class="cov8" title="1">{
        return &amp;ForwardList[T]{Head: nil}
}</span>

// DeepCopy создает глубокую копию списка
func (l *ForwardList[T]) DeepCopy() *ForwardList[T] <span class="cov8" title="1">{
        newList := NewForwardList[T]()
        if l.Head == nil </span><span class="cov8" title="1">{
                return newList
        }</span>

        <span class="cov8" title="1">newList.Head = &amp;FLNode[T]{Key: l.Head.Key, Next: nil}
        currentThis := newList.Head
        currentOther := l.Head.Next

        for currentOther != nil </span><span class="cov8" title="1">{
                currentThis.Next = &amp;FLNode[T]{Key: currentOther.Key, Next: nil}
                currentThis = currentThis.Next
                currentOther = currentOther.Next
        }</span>
        <span class="cov8" title="1">return newList</span>
}

// PushForward добавляет узел ПОСЛЕ указанного узла ptr
func (l *ForwardList[T]) PushForward(ptr *FLNode[T], key T) error <span class="cov8" title="1">{
        if ptr == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("pointer cannot be null")
        }</span>
        <span class="cov8" title="1">newNode := &amp;FLNode[T]{Key: key, Next: ptr.Next}
        ptr.Next = newNode
        return nil</span>
}

// Create создает список с начальным элементом (сбрасывает текущий)
func (l *ForwardList[T]) Create(keyBegin T) <span class="cov8" title="1">{
        l.Head = &amp;FLNode[T]{Key: keyBegin, Next: nil}
}</span>

// Print выводит список в консоль
func (l *ForwardList[T]) Print() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                fmt.Printf("%v -&gt; ", current.Key)
                current = current.Next
        }</span>
        <span class="cov8" title="1">fmt.Println("nil")</span>
}

// GetPrintString возвращает строковое представление (для тестов)
func (l *ForwardList[T]) GetPrintString() string <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return "Список пуст\n"
        }</span>
        <span class="cov8" title="1">var buffer bytes.Buffer
        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                buffer.WriteString(fmt.Sprintf("%v -&gt; ", current.Key))
                current = current.Next
        }</span>
        <span class="cov8" title="1">buffer.WriteString("nil\n")
        return buffer.String()</span>
}

// PushHead добавляет элемент в НАЧАЛО списка
func (l *ForwardList[T]) PushHead(key T) <span class="cov8" title="1">{
        newNode := &amp;FLNode[T]{Key: key, Next: l.Head}
        l.Head = newNode
}</span>

// PushBack добавляет элемент в КОНЕЦ списка
func (l *ForwardList[T]) PushBack(key T) <span class="cov8" title="1">{
        newNode := &amp;FLNode[T]{Key: key, Next: nil}
        if l.Head == nil </span><span class="cov8" title="1">{
                l.Head = newNode
                return
        }</span>
        <span class="cov8" title="1">current := l.Head
        for current.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = newNode</span>
}

// PushBefore добавляет элемент ДО узла с заданным значением
func (l *ForwardList[T]) PushBefore(targetKey T, newKey T) error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("list is empty, cannot find element")
        }</span>

        <span class="cov8" title="1">if l.Head.Key == targetKey </span><span class="cov8" title="1">{
                l.PushHead(newKey)
                return nil
        }</span>

        <span class="cov8" title="1">current := l.Head
        for current.Next != nil &amp;&amp; current.Next.Key != targetKey </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current.Next != nil </span><span class="cov8" title="1">{
                return l.PushForward(current, newKey)
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("target key not found")</span>
}

// DelHead удаляет первый элемент списка
func (l *ForwardList[T]) DelHead() error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("attempt to delete from an empty list")
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next
        return nil</span>
}

// DelBack удаляет последний элемент списка
func (l *ForwardList[T]) DelBack() error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("attempt to delete from an empty list")
        }</span>

        <span class="cov8" title="1">if l.Head.Next == nil </span><span class="cov8" title="1">{
                l.Head = nil
                return nil
        }</span>

        <span class="cov8" title="1">current := l.Head
        for current.Next.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = nil
        return nil</span>
}

// DelAfter удаляет элемент ПОСЛЕ указанного узла
func (l *ForwardList[T]) DelAfter(ptr *FLNode[T]) error <span class="cov8" title="1">{
        if ptr == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("pointer cannot be null")
        }</span>
        <span class="cov8" title="1">if ptr.Next == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no element exists after the specified node")
        }</span>
        <span class="cov8" title="1">ptr.Next = ptr.Next.Next
        return nil</span>
}

// DelBefore удаляет элемент ДО узла с заданным значением
func (l *ForwardList[T]) DelBefore(targetKey T) error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("list is empty")
        }</span>
        <span class="cov8" title="1">if l.Head.Key == targetKey </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot delete element before the head of the list")
        }</span>
        <span class="cov8" title="1">if l.Head.Next == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("list is too short or element not found")
        }</span>
        // Если целевой элемент - второй, нужно удалить голову
        <span class="cov8" title="1">if l.Head.Next.Key == targetKey </span><span class="cov8" title="1">{
                return l.DelHead()
        }</span>

        <span class="cov8" title="1">current := l.Head
        found := false
        // Ищем узел за два шага до целевого
        for current.Next != nil &amp;&amp; current.Next.Next != nil </span><span class="cov8" title="1">{
                if current.Next.Next.Key == targetKey </span><span class="cov8" title="1">{
                        l.DelAfter(current)
                        found = true
                        return nil
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("target element not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DelByValue удаляет узел по значению (первое вхождение)
func (l *ForwardList[T]) DelByValue(key T) error <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("list is empty")
        }</span>

        <span class="cov8" title="1">if l.Head.Key == key </span><span class="cov8" title="1">{
                return l.DelHead()
        }</span>

        <span class="cov8" title="1">current := l.Head
        for current.Next != nil &amp;&amp; current.Next.Key != key </span><span class="cov0" title="0">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current.Next != nil </span><span class="cov8" title="1">{
                current.Next = current.Next.Next
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("element with specified value not found")</span>
}

// GetByValue ищет элемент по значению
func (l *ForwardList[T]) GetByValue(key T) *FLNode[T] <span class="cov8" title="1">{
        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                if current.Key == key </span><span class="cov8" title="1">{
                        return current
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Save сохраняет список в текстовый файл
func (l *ForwardList[T]) Save(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error opening file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(file, "%v ", current.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Load загружает список из текстового файла
func (l *ForwardList[T]) Load(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error opening file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Очищаем список
        l.Head = nil

        var value T
        first := true
        for </span><span class="cov8" title="1">{
                _, err := fmt.Fscan(file, &amp;value)
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid data format or read error")
                }</span>

                <span class="cov8" title="1">if first </span><span class="cov8" title="1">{
                        l.Create(value)
                        first = false
                }</span> else<span class="cov8" title="1"> {
                        l.PushBack(value)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Serialize сохраняет список в бинарный формат (gob)
func (l *ForwardList[T]) Serialize(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error opening file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var values []T
        current := l.Head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.Key)
                current = current.Next
        }</span>

        <span class="cov8" title="1">encoder := gob.NewEncoder(file)
        if err := encoder.Encode(values); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing binary data: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Deserialize загружает список из бинарного формата (gob)
func (l *ForwardList[T]) Deserialize(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error opening file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        l.Head = nil
        var values []T
        decoder := gob.NewDecoder(file)
        if err := decoder.Decode(&amp;values); err != nil </span><span class="cov8" title="1">{
                // Если файл пуст или EOF, это нормально, просто список будет пуст
                if err == io.EOF </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("error reading binary data: %v", err)</span>
        }

        <span class="cov8" title="1">for i, val := range values </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        l.Create(val)
                }</span> else<span class="cov8" title="1"> {
                        l.PushBack(val)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package classes

import (
        "encoding/gob"
        "encoding/json"
        "fmt"
        "os"
)

type ArNode[T any] struct {
        Key T
}

type MyArray[T any] struct {
        data     []ArNode[T]
        size     int
        capacity int
}

func NewMyArray[T any]() *MyArray[T] <span class="cov8" title="1">{
        return &amp;MyArray[T]{
                data:     make([]ArNode[T], 10),
                size:     0,
                capacity: 10,
        }
}</span>

func NewMyArrayWithCapacity[T any](initCap int) *MyArray[T] <span class="cov8" title="1">{
        return &amp;MyArray[T]{
                data:     make([]ArNode[T], initCap),
                size:     0,
                capacity: initCap,
        }
}</span>

func (a *MyArray[T]) Get(index int) (T, error) <span class="cov8" title="1">{
        var zero T
        if index &lt; 0 || index &gt;= a.capacity </span><span class="cov8" title="1">{
                return zero, fmt.Errorf("index out of array bounds")
        }</span>
        <span class="cov8" title="1">return a.data[index].Key, nil</span>
}

func (a *MyArray[T]) Set(index int, value T) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= a.capacity </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of array bounds")
        }</span>
        <span class="cov8" title="1">a.data[index].Key = value
        return nil</span>
}

func (a *MyArray[T]) resize() <span class="cov8" title="1">{
        newCap := a.capacity * 2
        if newCap == 0 </span><span class="cov8" title="1">{
                newCap = 1
        }</span>
        <span class="cov8" title="1">newData := make([]ArNode[T], newCap)

        if a.size &gt; 0 </span><span class="cov8" title="1">{
                copy(newData, a.data)
        }</span>

        <span class="cov8" title="1">a.data = newData
        a.capacity = newCap</span>
}

func (a *MyArray[T]) MPUSHBack(key T) <span class="cov8" title="1">{
        if a.size &gt;= a.capacity </span><span class="cov8" title="1">{
                a.resize()
        }</span>
        <span class="cov8" title="1">a.data[a.size].Key = key
        a.size++</span>
}

func (a *MyArray[T]) MPUSHIndex(index int, key T) error <span class="cov8" title="1">{
        if index &gt; a.capacity || index &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("array index out of bounds")
        }</span>

        <span class="cov8" title="1">if a.size &gt;= a.capacity </span><span class="cov8" title="1">{
                a.resize()
        }</span>

        <span class="cov8" title="1">for i := a.size - 1; i &gt;= index; i-- </span><span class="cov8" title="1">{
                a.data[i+1] = a.data[i]
        }</span>
        <span class="cov8" title="1">a.data[index].Key = key
        a.size++
        return nil</span>
}

func (a *MyArray[T]) MGET(index int) (T, error) <span class="cov8" title="1">{
        var zero T
        if index &gt;= a.capacity || index &lt; 0 </span><span class="cov0" title="0">{
                return zero, fmt.Errorf("array index out of bounds")
        }</span>
        <span class="cov8" title="1">return a.data[index].Key, nil</span>
}

func (a *MyArray[T]) MDEL(index int) error <span class="cov8" title="1">{
        var zero T
        if index &gt;= a.capacity || index &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("array index out of bounds")
        }</span>

        <span class="cov8" title="1">for i := index; i &lt; a.capacity-1; i++ </span><span class="cov8" title="1">{
                a.data[i] = a.data[i+1]
        }</span>
        <span class="cov8" title="1">a.data[a.capacity-1].Key = zero
        a.size--
        return nil</span>
}

func (a *MyArray[T]) MSWAP(index int, swapkey T) error <span class="cov8" title="1">{
        if index &gt;= a.size || index &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("array index out of bounds")
        }</span>
        <span class="cov8" title="1">a.data[index].Key = swapkey
        return nil</span>
}

func (a *MyArray[T]) Print() <span class="cov8" title="1">{
        for i := 0; i &lt; a.capacity; i++ </span><span class="cov8" title="1">{
                fmt.Printf("%v ", a.data[i].Key)
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

func (a *MyArray[T]) MSize() int <span class="cov8" title="1">{
        return a.size
}</span>

func (a *MyArray[T]) SaveText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        type SaveData struct {
                Size     int
                Capacity int
                Data     []T
        }

        keys := make([]T, a.capacity)
        for i := 0; i &lt; a.capacity; i++ </span><span class="cov8" title="1">{
                keys[i] = a.data[i].Key
        }</span>

        <span class="cov8" title="1">saveData := SaveData{
                Size:     a.size,
                Capacity: a.capacity,
                Data:     keys,
        }

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(saveData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error encoding  %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *MyArray[T]) LoadText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        type SaveData struct {
                Size     int
                Capacity int
                Data     []T
        }

        var saveData SaveData
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;saveData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding  %v", err)
        }</span>

        <span class="cov8" title="1">a.size = saveData.Size
        a.capacity = saveData.Capacity
        a.data = make([]ArNode[T], a.capacity)

        for i := 0; i &lt; a.capacity &amp;&amp; i &lt; len(saveData.Data); i++ </span><span class="cov8" title="1">{
                a.data[i].Key = saveData.Data[i]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *MyArray[T]) SaveBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for writing: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := gob.NewEncoder(file)

        if err := encoder.Encode(a.size); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := encoder.Encode(a.capacity); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; a.capacity; i++ </span><span class="cov8" title="1">{
                if err := encoder.Encode(a.data[i].Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (a *MyArray[T]) LoadBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for reading: %v", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := gob.NewDecoder(file)

        var newSize, newCapacity int
        if err := decoder.Decode(&amp;newSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := decoder.Decode(&amp;newCapacity); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.size = newSize
        a.capacity = newCapacity
        a.data = make([]ArNode[T], a.capacity)

        for i := 0; i &lt; a.capacity; i++ </span><span class="cov8" title="1">{
                if err := decoder.Decode(&amp;a.data[i].Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package classes

import (
        "encoding/gob"
        "errors"
        "fmt"
        "io"
        "os"
)

// Ошибки, которые может вернуть очередь
var (
        ErrMyQueueEmpty = errors.New("MyQueue is empty")
        ErrFileCorrupt  = errors.New("file corrupted or invalid data size")
)

// MyQueue реализует кольцевой буфер
type MyQueue[T any] struct {
        data     []T
        head     int
        tail     int
        count    int // Текущее количество элементов (size)
        capacity int // Вместимость
}

// NewMyQueue создает новую очередь с заданной начальной вместимостью
func NewMyQueue[T any](initialCap int) *MyQueue[T] <span class="cov8" title="1">{
        if initialCap &lt; 1 </span><span class="cov8" title="1">{
                initialCap = 1
        }</span>
        <span class="cov8" title="1">return &amp;MyQueue[T]{
                data:     make([]T, initialCap),
                capacity: initialCap,
                head:     0,
                tail:     0,
                count:    0,
        }</span>
}

// resize увеличивает размер внутреннего массива в 2 раза
func (q *MyQueue[T]) resize() <span class="cov8" title="1">{
        newCapacity := q.capacity * 2
        if newCapacity == 0 </span><span class="cov8" title="1">{
                newCapacity = 1
        }</span>
        <span class="cov8" title="1">newData := make([]T, newCapacity)

        // Копируем элементы, "распрямляя" кольцо
        for i := 0; i &lt; q.count; i++ </span><span class="cov8" title="1">{
                newData[i] = q.data[(q.head+i)%q.capacity]
        }</span>

        <span class="cov8" title="1">q.data = newData
        q.capacity = newCapacity
        q.head = 0
        q.tail = q.count</span>
}

// Push добавляет элемент в конец очереди
func (q *MyQueue[T]) Push(value T) <span class="cov8" title="1">{
        if q.count &gt;= q.capacity </span><span class="cov8" title="1">{
                q.resize()
        }</span>
        <span class="cov8" title="1">q.data[q.tail] = value
        q.tail = (q.tail + 1) % q.capacity
        q.count++</span>
}

// Pop извлекает элемент из начала очереди
func (q *MyQueue[T]) Pop() (T, error) <span class="cov8" title="1">{
        var empty T
        if q.count == 0 </span><span class="cov8" title="1">{
                return empty, ErrMyQueueEmpty
        }</span>

        <span class="cov8" title="1">value := q.data[q.head]
        var zero T
        q.data[q.head] = zero

        q.head = (q.head + 1) % q.capacity
        q.count--
        return value, nil</span>
}

// Get возвращает первый элемент без удаления
func (q *MyQueue[T]) Get() (T, error) <span class="cov8" title="1">{
        if q.count == 0 </span><span class="cov8" title="1">{
                var empty T
                return empty, ErrMyQueueEmpty
        }</span>
        <span class="cov8" title="1">return q.data[q.head], nil</span>
}

// IsEmpty проверяет, пуста ли очередь
func (q *MyQueue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return q.count == 0
}</span>

// Size возвращает количество элементов
func (q *MyQueue[T]) Size() int <span class="cov8" title="1">{
        return q.count
}</span>

// Clone создает глубокую копию очереди
func (q *MyQueue[T]) Clone() *MyQueue[T] <span class="cov8" title="1">{
        newQ := &amp;MyQueue[T]{
                capacity: q.capacity,
                count:    q.count,
                head:     q.head,
                tail:     q.tail,
                data:     make([]T, q.capacity),
        }
        copy(newQ.data, q.data)
        return newQ
}</span>

// Print выводит содержимое очереди
func (q *MyQueue[T]) Print(w io.Writer) <span class="cov8" title="1">{
        fmt.Fprint(w, "Содержимое очереди (от головы к хвосту): ")
        if q.count == 0 </span><span class="cov8" title="1">{
                fmt.Fprintln(w, "пусто")
                return
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; q.count; i++ </span><span class="cov8" title="1">{
                val := q.data[(q.head+i)%q.capacity]
                fmt.Fprintf(w, "%v ", val)
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(w)</span>
}

// Сериализация (Text)

// SaveText сохраняет очередь в текстовый файл.
func (q *MyQueue[T]) SaveText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Записываем размер
        if _, err := fmt.Fprintln(file, q.count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Записываем элементы
        <span class="cov8" title="1">for i := 0; i &lt; q.count; i++ </span><span class="cov8" title="1">{
                val := q.data[(q.head+i)%q.capacity]
                if _, err := fmt.Fprintln(file, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LoadText загружает очередь из текстового файла
func (q *MyQueue[T]) LoadText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var newSize int
        if _, err := fmt.Fscan(file, &amp;newSize); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error reading size: %w", err)
        }</span>

        // Сбрасываем текущую очередь
        <span class="cov8" title="1">q.head = 0
        q.tail = 0
        q.count = 0
        // capacity оставляем или можем пересоздать slice, если нужно

        for i := 0; i &lt; newSize; i++ </span><span class="cov8" title="1">{
                var val T
                // fmt.Fscan работает хорошо для базовых типов (int, string, float)
                // Для сложных структур потребуется кастомная логика.
                if _, err := fmt.Fscan(file, &amp;val); err != nil </span><span class="cov8" title="1">{
                        // Если достигли конца файла раньше времени или ошибка парсинга
                        return ErrFileCorrupt
                }</span>
                <span class="cov8" title="1">q.Push(val)</span>
        }

        <span class="cov8" title="1">if q.count != newSize </span><span class="cov0" title="0">{
                return ErrFileCorrupt
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Сериализация (Binary)

// SaveBinary сохраняет данные
func (q *MyQueue[T]) SaveBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := gob.NewEncoder(file)

        // Пишем размер
        if err := encoder.Encode(q.count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Пишем элементы в логическом порядке
        <span class="cov8" title="1">for i := 0; i &lt; q.count; i++ </span><span class="cov8" title="1">{
                val := q.data[(q.head+i)%q.capacity]
                if err := encoder.Encode(val); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LoadBinary загружает данные используя encoding/gob
func (q *MyQueue[T]) LoadBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := gob.NewDecoder(file)

        var newSize int
        if err := decoder.Decode(&amp;newSize); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error reading header: %w", err)
        }</span>

        // Сброс
        <span class="cov8" title="1">q.head = 0
        q.tail = 0
        q.count = 0

        for i := 0; i &lt; newSize; i++ </span><span class="cov8" title="1">{
                var val T
                if err := decoder.Decode(&amp;val); err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return ErrFileCorrupt
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
                <span class="cov8" title="1">q.Push(val)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package classes

import (
        "encoding/gob"
        "errors"
        "fmt"
        "os"
)

// MyStack реализует структуру данных стек
type MyStack[T any] struct {
        data []T
}

// NewMyStack создает новый пустой стек.
func NewMyStack[T any]() *MyStack[T] <span class="cov8" title="1">{
        return &amp;MyStack[T]{
                data: make([]T, 0, 1),
        }
}</span>

// NewMyStackWithCapacity создает стек с заданной начальной емкостью.
func NewMyStackWithCapacity[T any](cap int) (*MyStack[T], error) <span class="cov8" title="1">{
        if cap &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("initial capacity must be greater than 0")
        }</span>
        <span class="cov8" title="1">return &amp;MyStack[T]{
                data: make([]T, 0, cap),
        }, nil</span>
}

// Push добавляет элемент в стек.
func (s *MyStack[T]) Push(value T) <span class="cov8" title="1">{
        s.data = append(s.data, value)
}</span>

// Pop извлекает элемент с вершины стека.
func (s *MyStack[T]) Pop() (T, error) <span class="cov8" title="1">{
        var zero T
        if len(s.data) == 0 </span><span class="cov8" title="1">{
                return zero, errors.New("MyStack underflow: cannot pop from an empty MyStack")
        }</span>

        <span class="cov8" title="1">index := len(s.data) - 1
        val := s.data[index]

        // Удаляем элемент из слайса (срезаем)
        s.data = s.data[:index]

        return val, nil</span>
}

// Size возвращает текущее количество элементов.
func (s *MyStack[T]) Size() int <span class="cov8" title="1">{
        return len(s.data)
}</span>

// Print выводит содержимое стека в консоль.
func (s *MyStack[T]) Print() <span class="cov8" title="1">{
        for _, v := range s.data </span><span class="cov8" title="1">{
                fmt.Printf("%v ", v)
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Clone создает глубокую копию стека
func (s *MyStack[T]) Clone() *MyStack[T] <span class="cov8" title="1">{
        newData := make([]T, len(s.data), cap(s.data))
        copy(newData, s.data)
        return &amp;MyStack[T]{data: newData}
}</span>

// SaveText сохраняет стек в текстовый файл
func (s *MyStack[T]) SaveText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for writing: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Записываем размер
        if _, err := fmt.Fprintln(file, len(s.data)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Записываем данные через пробел
        <span class="cov8" title="1">for _, v := range s.data </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(file, "%v ", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LoadText загружает стек из текстового файла
func (s *MyStack[T]) LoadText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open file for reading: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var size int
        if _, err := fmt.Fscan(file, &amp;size); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read MyStack size: %w", err)
        }</span>

        // Очищаем текущий стек и выделяем память
        <span class="cov8" title="1">s.data = make([]T, 0, size)

        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                var val T
                // Fscan автоматически парсит типы, разделенные пробелами
                if _, err := fmt.Fscan(file, &amp;val); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to read data at index %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">s.Push(val)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SaveBinary сохраняет стек в бинарном формате
func (s *MyStack[T]) SaveBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open binary file for writing: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := gob.NewEncoder(file)
        if err := encoder.Encode(s.data); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to encode data: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadBinary загружает стек из бинарного файла
func (s *MyStack[T]) LoadBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not open binary file for reading: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        decoder := gob.NewDecoder(file)
        var newData []T
        if err := decoder.Decode(&amp;newData); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to decode data: %w", err)
        }</span>

        <span class="cov8" title="1">s.data = newData
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package classes

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "io"
        "os"
)

// OTNode represents a key-value node in the hash table
type OTNode[Key comparable, Value any] struct {
        key   Key
        value Value
}

// OpenTable is a hash table implementation with linear probing
type OpenTable[Key comparable, Value any] struct {
        buckets           []OTNode[Key, Value]
        countItems        int
        bucketsThersSmtng int
}

// NewOpenTable creates a new hash table with specified initial capacity
func NewOpenTable[Key comparable, Value any](initCap int) *OpenTable[Key, Value] <span class="cov8" title="1">{
        if initCap &lt;= 0 </span><span class="cov8" title="1">{
                initCap = 10
        }</span>
        <span class="cov8" title="1">return &amp;OpenTable[Key, Value]{
                buckets:           make([]OTNode[Key, Value], initCap),
                countItems:        0,
                bucketsThersSmtng: 0,
        }</span>
}

// hashInt computes hash for integer keys
func (ot *OpenTable[Key, Value]) hashInt(key int) int <span class="cov8" title="1">{
        hash := 0
        for key &gt; 0 </span><span class="cov8" title="1">{
                hash ^= (key &amp; 0xFF)
                key &gt;&gt;= 8
        }</span>
        <span class="cov8" title="1">return hash % len(ot.buckets)</span>
}

// hashString computes hash for string keys
func (ot *OpenTable[Key, Value]) hashString(key string) int <span class="cov8" title="1">{
        sum := 0
        for _, c := range key </span><span class="cov8" title="1">{
                sum += int(uint8(c))
        }</span>

        <span class="cov8" title="1">result := (sum % (len(ot.buckets) - 1)) + 1

        // Make result odd if table size is even
        if len(ot.buckets)%2 == 0 &amp;&amp; result%2 == 0 </span><span class="cov8" title="1">{
                result++
        }</span>

        <span class="cov8" title="1">return result</span>
}

// hash computes the hash based on key type
func (ot *OpenTable[Key, Value]) hash(key Key) int <span class="cov8" title="1">{
        var anyKey any = key
        switch k := anyKey.(type) </span>{
        case int:<span class="cov8" title="1">
                return ot.hashInt(k)</span>
        case string:<span class="cov8" title="1">
                return ot.hashString(k)</span>
        default:<span class="cov0" title="0">
                // For other types, use a simple hash
                s := fmt.Sprintf("%v", key)
                if len(s) == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return int(s[0]) % len(ot.buckets)</span>
        }
}

// getBucketIndex returns the bucket index for a given key
func (ot *OpenTable[Key, Value]) getBucketIndex(key Key) int <span class="cov8" title="1">{
        return ot.hash(key) % len(ot.buckets)
}</span>

// rehash expands the hash table and rehashes all elements
func (ot *OpenTable[Key, Value]) rehash() <span class="cov8" title="1">{
        oldBuckets := ot.buckets
        ot.buckets = make([]OTNode[Key, Value], len(oldBuckets)*2)
        ot.countItems = 0
        ot.bucketsThersSmtng = 0

        var zeroKey Key
        for i := 0; i &lt; len(oldBuckets); i++ </span><span class="cov8" title="1">{
                if oldBuckets[i].key != zeroKey </span><span class="cov8" title="1">{
                        ot.Insert(oldBuckets[i].key, oldBuckets[i].value)
                }</span>
        }
}

// Find checks if a key exists in the hash table
func (ot *OpenTable[Key, Value]) Find(key Key) bool <span class="cov8" title="1">{
        if ot.countItems == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var zeroKey Key
        index := ot.getBucketIndex(key)
        start := index

        for ot.buckets[index].key != zeroKey </span><span class="cov8" title="1">{
                if ot.buckets[index].key == key </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">index = (index + 1) % len(ot.buckets)
                if index == start </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// Insert adds a key-value pair to the hash table
func (ot *OpenTable[Key, Value]) Insert(key Key, val Value) <span class="cov8" title="1">{
        if ot.Find(key) </span><span class="cov8" title="1">{
                return // Key already exists
        }</span>

        <span class="cov8" title="1">var zeroKey Key
        index := ot.getBucketIndex(key)
        start := index

        // Linear probing
        for ot.buckets[index].key != zeroKey </span><span class="cov8" title="1">{
                index = (index + 1) % len(ot.buckets)
                if index == start </span><span class="cov0" title="0">{
                        // Table is full - rehash
                        ot.rehash()
                        ot.Insert(key, val)
                        return
                }</span>
        }

        <span class="cov8" title="1">if ot.buckets[index].key == zeroKey </span><span class="cov8" title="1">{
                ot.bucketsThersSmtng++
        }</span>
        <span class="cov8" title="1">ot.buckets[index].key = key
        ot.buckets[index].value = val
        ot.countItems++

        // Rehash if load factor &gt; 0.75
        if ot.countItems*4 &gt; len(ot.buckets)*3 </span><span class="cov8" title="1">{
                ot.rehash()
        }</span>

        // Rehash if bucket usage &gt;= 0.9
        <span class="cov8" title="1">if float64(ot.bucketsThersSmtng)/float64(len(ot.buckets)) &gt;= 0.9 </span><span class="cov0" title="0">{
                ot.rehash()
        }</span>
}

// Erase removes a key from the hash table
func (ot *OpenTable[Key, Value]) Erase(key Key) <span class="cov8" title="1">{
        if ot.countItems == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var zeroKey Key
        var zeroValue Value
        index := ot.getBucketIndex(key)

        for ot.buckets[index].key != key </span><span class="cov0" title="0">{
                index = (index + 1) % len(ot.buckets)
        }</span>

        <span class="cov8" title="1">ot.buckets[index].key = zeroKey
        ot.buckets[index].value = zeroValue
        ot.countItems--</span>
}

// Size returns the number of elements in the hash table
func (ot *OpenTable[Key, Value]) Size() int <span class="cov8" title="1">{
        return ot.countItems
}</span>

// Empty checks if the hash table is empty
func (ot *OpenTable[Key, Value]) Empty() bool <span class="cov8" title="1">{
        return ot.countItems == 0
}</span>

// GetCap returns the capacity of the hash table
func (ot *OpenTable[Key, Value]) GetCap() int <span class="cov8" title="1">{
        return len(ot.buckets)
}</span>

// GetKey returns the key at the specified index
func (ot *OpenTable[Key, Value]) GetKey(i int) Key <span class="cov8" title="1">{
        return ot.buckets[i].key
}</span>

// GetValue returns the value associated with the given key
func (ot *OpenTable[Key, Value]) GetValue(k Key) Value <span class="cov8" title="1">{
        index := ot.getBucketIndex(k)
        for ot.buckets[index].key != k </span><span class="cov8" title="1">{
                index = (index + 1) % len(ot.buckets)
        }</span>
        <span class="cov8" title="1">return ot.buckets[index].value</span>
}

// SPRINT prints all key-value pairs in the hash table
func (ot *OpenTable[Key, Value]) SPRINT() <span class="cov8" title="1">{
        var zeroKey Key
        for i := 0; i &lt; len(ot.buckets); i++ </span><span class="cov8" title="1">{
                if ot.buckets[i].key != zeroKey </span><span class="cov8" title="1">{
                        fmt.Printf("%v %v\n", ot.buckets[i].key, ot.buckets[i].value)
                }</span>
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

// SaveText saves the hash table to a text file
func (ot *OpenTable[Key, Value]) SaveText(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        writer := bufio.NewWriter(file)

        // Write metadata
        fmt.Fprintf(writer, "%d\n", ot.countItems)
        fmt.Fprintf(writer, "%d\n", len(ot.buckets))
        fmt.Fprintf(writer, "%d\n", ot.bucketsThersSmtng)

        // Write key-value pairs
        var zeroKey Key
        for i := 0; i &lt; len(ot.buckets); i++ </span><span class="cov8" title="1">{
                if ot.buckets[i].key != zeroKey </span><span class="cov8" title="1">{
                        fmt.Fprintf(writer, "%v\n", ot.buckets[i].key)
                        fmt.Fprintf(writer, "%v\n", ot.buckets[i].value)
                }</span>
        }

        <span class="cov8" title="1">return writer.Flush()</span>
}

// LoadText loads the hash table from a text file
func (ot *OpenTable[Key, Value]) LoadText(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)

        var newCountItems, newCapacity, newBucketsThersSmtng int

        scanner.Scan()
        fmt.Sscanf(scanner.Text(), "%d", &amp;newCountItems)
        scanner.Scan()
        fmt.Sscanf(scanner.Text(), "%d", &amp;newCapacity)
        scanner.Scan()
        fmt.Sscanf(scanner.Text(), "%d", &amp;newBucketsThersSmtng)

        // Recreate table with new capacity
        ot.buckets = make([]OTNode[Key, Value], newCapacity)
        ot.countItems = 0
        ot.bucketsThersSmtng = 0

        // Read and insert key-value pairs
        for i := 0; i &lt; newCountItems; i++ </span><span class="cov8" title="1">{
                var key Key
                var val Value

                scanner.Scan()
                fmt.Sscanf(scanner.Text(), "%v", &amp;key)
                scanner.Scan()
                fmt.Sscanf(scanner.Text(), "%v", &amp;val)

                ot.Insert(key, val)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveBinary saves the hash table to a binary file
func (ot *OpenTable[Key, Value]) SaveBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Write metadata
        binary.Write(file, binary.LittleEndian, int64(ot.countItems))
        binary.Write(file, binary.LittleEndian, int64(len(ot.buckets)))
        binary.Write(file, binary.LittleEndian, int64(ot.bucketsThersSmtng))

        // Write key-value pairs
        var zeroKey Key
        for i := 0; i &lt; len(ot.buckets); i++ </span><span class="cov8" title="1">{
                if ot.buckets[i].key != zeroKey </span><span class="cov8" title="1">{
                        writeValue(file, ot.buckets[i].key)
                        writeValue(file, ot.buckets[i].value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LoadBinary loads the hash table from a binary file
func (ot *OpenTable[Key, Value]) LoadBinary(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var newCountItems, newCapacity, newBucketsThersSmtng int64
        binary.Read(file, binary.LittleEndian, &amp;newCountItems)
        binary.Read(file, binary.LittleEndian, &amp;newCapacity)
        binary.Read(file, binary.LittleEndian, &amp;newBucketsThersSmtng)

        // Recreate table with new capacity
        ot.buckets = make([]OTNode[Key, Value], newCapacity)
        ot.countItems = 0
        ot.bucketsThersSmtng = 0

        // Read and insert key-value pairs
        for i := 0; i &lt; int(newCountItems); i++ </span><span class="cov8" title="1">{
                var key Key
                var val Value

                readValue(file, &amp;key)
                readValue(file, &amp;val)

                ot.Insert(key, val)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Helper function to write values to binary file
func writeValue(w io.Writer, v any) error <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case int:<span class="cov8" title="1">
                return binary.Write(w, binary.LittleEndian, int64(val))</span>
        case string:<span class="cov8" title="1">
                length := int64(len(val))
                binary.Write(w, binary.LittleEndian, length)
                _, err := w.Write([]byte(val))
                return err</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported type for binary write")</span>
        }
}

// Helper function to read values from binary file
func readValue(r io.Reader, v any) error <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case *int:<span class="cov8" title="1">
                var i int64
                err := binary.Read(r, binary.LittleEndian, &amp;i)
                *val = int(i)
                return err</span>
        case *string:<span class="cov8" title="1">
                var length int64
                binary.Read(r, binary.LittleEndian, &amp;length)
                buf := make([]byte, length)
                _, err := r.Read(buf)
                *val = string(buf)
                return err</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported type for binary read")</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package classes

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "io"
        "os"
        "strings"
)

type TableHash struct {
        // Исправление 1: Указываем конкретный тип [string] для дженерика
        buckets           []*ForwardList[string]
        countItems        int
        bucketsThereSmtng int
        loadFactor        float64
}

// NewTableHash создает таблицу.
func NewTableHash(initCap int) *TableHash <span class="cov8" title="1">{
        if initCap &lt; 2 </span><span class="cov8" title="1">{
                initCap = 10
        }</span>
        <span class="cov8" title="1">ht := &amp;TableHash{
                // Исправление 2: make создает слайс указателей на ForwardList[string]
                buckets:    make([]*ForwardList[string], initCap),
                loadFactor: 0.75,
        }
        for i := range ht.buckets </span><span class="cov8" title="1">{
                // Исправление 3: Вызываем конструктор с типом [string]() без аргументов
                ht.buckets[i] = NewForwardList[string]()
        }</span>
        <span class="cov8" title="1">return ht</span>
}

func (ht *TableHash) Clear() <span class="cov8" title="1">{
        *ht = *NewTableHash(10)
}</span>

func (ht *TableHash) Size() int   <span class="cov8" title="1">{ return ht.countItems }</span>
func (ht *TableHash) Empty() bool <span class="cov8" title="1">{ return ht.countItems == 0 }</span>

// --- кодирование пары key/value в одну строку списка ---
func encodeKV(key, value string) string <span class="cov8" title="1">{
        return key + "\t" + value
}</span>

func decodeKV(s string) (key, value string, ok bool) <span class="cov8" title="1">{
        k, v, found := strings.Cut(s, "\t")
        if !found </span><span class="cov0" title="0">{
                return "", "", false
        }</span>
        <span class="cov8" title="1">return k, v, true</span>
}

// --- hash ---
func (ht *TableHash) hashString(key string) int <span class="cov8" title="1">{
        capacity := len(ht.buckets)
        sum := 0
        for i := 0; i &lt; len(key); i++ </span><span class="cov8" title="1">{
                sum += int(uint8(key[i]))
        }</span>

        <span class="cov8" title="1">result := (sum % (capacity - 1)) + 1
        if capacity%2 == 0 &amp;&amp; result%2 == 0 </span><span class="cov8" title="1">{
                result++
        }</span>
        <span class="cov8" title="1">return result % capacity</span>
}

func (ht *TableHash) bucketIndex(key string) int <span class="cov8" title="1">{
        return ht.hashString(key)
}</span>

// --- внутренние операции по списку ---

// Исправление 4: bucket теперь *ForwardList[string]
func (ht *TableHash) findInBucket(bucket *ForwardList[string], key string) (value string, found bool) <span class="cov8" title="1">{
        // Исправление 5: Итерация через Head (а не head), Next (а не next) и Key (а не val)
        for n := bucket.Head; n != nil; n = n.Next </span><span class="cov8" title="1">{
                k, v, ok := decodeKV(n.Key)
                if ok &amp;&amp; k == key </span><span class="cov8" title="1">{
                        return v, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func (ht *TableHash) deleteFromBucket(bucket *ForwardList[string], key string) (deleted bool) <span class="cov8" title="1">{
        // Исправление 6: Используем FLNode[string] вместо FNode
        var prev *FLNode[string]
        for cur := bucket.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                k, _, ok := decodeKV(cur.Key)
                if ok &amp;&amp; k == key </span><span class="cov8" title="1">{
                        if prev == nil </span><span class="cov8" title="1">{
                                bucket.Head = cur.Next
                        }</span> else<span class="cov8" title="1"> {
                                prev.Next = cur.Next
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
                <span class="cov8" title="1">prev = cur</span>
        }
        <span class="cov8" title="1">return false</span>
}

// --- публичное API ---
func (ht *TableHash) Contains(key string) bool <span class="cov8" title="1">{
        if ht.countItems == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">idx := ht.bucketIndex(key)
        _, found := ht.findInBucket(ht.buckets[idx], key)
        return found</span>
}

func (ht *TableHash) Add(key, value string) <span class="cov8" title="1">{
        if ht.Contains(key) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if float64(ht.countItems)/float64(len(ht.buckets)) &gt;= ht.loadFactor </span><span class="cov8" title="1">{
                ht.rehash()
        }</span>

        <span class="cov8" title="1">idx := ht.bucketIndex(key)
        // Исправление 7: Проверка через Head
        if ht.buckets[idx].Head == nil </span><span class="cov8" title="1">{
                ht.bucketsThereSmtng++
        }</span>

        // Исправление 8: Используем PushBack вместо InsertAtTail
        <span class="cov8" title="1">ht.buckets[idx].PushBack(encodeKV(key, value))
        ht.countItems++

        if float64(ht.bucketsThereSmtng)/float64(len(ht.buckets)) &gt;= 0.9 </span><span class="cov0" title="0">{
                ht.rehash()
        }</span>
}

func (ht *TableHash) Get(key string) (string, bool) <span class="cov8" title="1">{
        idx := ht.bucketIndex(key)
        return ht.findInBucket(ht.buckets[idx], key)
}</span>

func (ht *TableHash) Delete(key string) <span class="cov8" title="1">{
        if ht.countItems == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">idx := ht.bucketIndex(key)
        b := ht.buckets[idx]
        if b.Head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">deleted := ht.deleteFromBucket(b, key)
        if !deleted </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ht.countItems--
        if b.Head == nil </span><span class="cov8" title="1">{
                ht.bucketsThereSmtng--
        }</span>
}

func (ht *TableHash) Print() <span class="cov8" title="1">{
        for i := range ht.buckets </span><span class="cov8" title="1">{
                // Исправление 9: Доступ через Head, Key, Next
                for n := ht.buckets[i].Head; n != nil; n = n.Next </span><span class="cov8" title="1">{
                        k, v, ok := decodeKV(n.Key)
                        if ok </span><span class="cov8" title="1">{
                                fmt.Printf("%s %s  ", k, v)
                        }</span>
                }
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

// --- rehash ---
func (ht *TableHash) rehash() <span class="cov8" title="1">{
        old := ht.buckets
        newCap := len(old) * 2
        if newCap &lt; 2 </span><span class="cov0" title="0">{
                newCap = 10
        }</span>

        <span class="cov8" title="1">ht.buckets = make([]*ForwardList[string], newCap)
        for i := range ht.buckets </span><span class="cov8" title="1">{
                ht.buckets[i] = NewForwardList[string]()
        }</span>
        <span class="cov8" title="1">ht.countItems = 0
        ht.bucketsThereSmtng = 0

        for i := range old </span><span class="cov8" title="1">{
                for n := old[i].Head; n != nil; n = n.Next </span><span class="cov8" title="1">{
                        k, v, ok := decodeKV(n.Key)
                        if ok </span><span class="cov8" title="1">{
                                ht.Add(k, v)
                        }</span>
                }
        }
}

// --- Text save/load ---
func (ht *TableHash) SaveText(filename string) error <span class="cov8" title="1">{
        f, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        w := bufio.NewWriter(f)
        if _, err := fmt.Fprintln(w, ht.countItems); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range ht.buckets </span><span class="cov8" title="1">{
                for n := ht.buckets[i].Head; n != nil; n = n.Next </span><span class="cov8" title="1">{
                        k, v, ok := decodeKV(n.Key)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, err := fmt.Fprintln(w, k, v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return w.Flush()</span>
}

func (ht *TableHash) LoadText(filename string) error <span class="cov8" title="1">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        ht.Clear()

        r := bufio.NewReader(f)
        var n int
        if _, err := fmt.Fscanln(r, &amp;n); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                var k, v string
                if _, err := fmt.Fscanln(r, &amp;k, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ht.Add(k, v)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// --- Binary save/load ---
func writeU64(w io.Writer, x uint64) error <span class="cov8" title="1">{
        return binary.Write(w, binary.LittleEndian, x)
}</span>
func readU64(r io.Reader, x *uint64) error <span class="cov8" title="1">{
        return binary.Read(r, binary.LittleEndian, x)
}</span>

func writeString(w io.Writer, s string) error <span class="cov8" title="1">{
        l := uint32(len(s))
        if err := binary.Write(w, binary.LittleEndian, l); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if l == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">_, err := w.Write([]byte(s))
        return err</span>
}

func readString(r io.Reader) (string, error) <span class="cov8" title="1">{
        var l uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;l); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if l == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">buf := make([]byte, l)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(buf), nil</span>
}

func (ht *TableHash) SaveBinary(filename string) error <span class="cov8" title="1">{
        f, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        if err := writeU64(f, uint64(ht.countItems)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range ht.buckets </span><span class="cov8" title="1">{
                for n := ht.buckets[i].Head; n != nil; n = n.Next </span><span class="cov8" title="1">{
                        k, v, ok := decodeKV(n.Key)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err := writeString(f, k); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := writeString(f, v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (ht *TableHash) LoadBinary(filename string) error <span class="cov8" title="1">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        ht.Clear()

        var n uint64
        if err := readU64(f, &amp;n); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := uint64(0); i &lt; n; i++ </span><span class="cov8" title="1">{
                k, err := readString(f)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">v, err := readString(f)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ht.Add(k, v)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
